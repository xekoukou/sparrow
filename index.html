<!DOCTYPE html>
<html>
<head>
<title>Sparrow</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="Markdown.Converter.js"></script>
<script src="Markdown.Extra.js"></script>
<script src="jquery-2.1.4.min.js"></script>
<link rel="stylesheet" href="highlight/styles/default.css">
<script src="highlight/highlight.pack.js"></script>
<script src="MathJax-master/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="markdown.js"></script>
<link rel="stylesheet" href="markdown.css">
</head>
<body>
    <div style = "font-size:120%">
       <h1 style='text-align: center'>Sparrow</h1>
       <div class="markdown">


Sparrow is a network library for the idris language with the purpose of permitting fast asynchronous communication whie at the same time allowing protocol verifiability at compile time and being very simple to use.

TODO Explain the main goals of this library in detail. 
a) Easy and cost effective to build.
b) inspectable and understandable by everyone, even people that do not know how to program.
c) Adaptable as time passes and composable. Different parts of the protocol can be different as long as there is no direct interaction between those different parts.


TODO Explain the difficulties of building a network library in a functional programming language in which all data are immutable. Especially, there can be no callbacks. Thus we need to wrap the epoll for linux.


OK the first try would be to simply write a small program that does compile and work.

We will use an object to store the data of our epoll wrapper.

TODO. Sparrow does not buffer data. The application needs to do that itself. The application knows better the specific needs that it has and thus the buffering that it requires. The buffer can be put inside the validation function.

```c
#define _GNU_SOURCE

#include %ltsys/epoll.h%gt
#include %lterrno.h%gt
#include %ltsearch.h%gt
#include %ltstdio.h%gt
#include %ltsys/socket.h%gt
#include %ltsys/types.h%gt
#include %ltnetdb.h%gt
#include %ltunistd.h%gt
#include %ltassert.h%gt
#include %ltstring.h%gt
#include %ltfcntl.h%gt
#include %ltstdlib.h%gt
#include %ltnetinet/in.h%gt
#include %ltnetinet/tcp.h%gt

#define MAX_EVENTS 32
// #define MAX_DELAY 40 //in milliseconds. We wait that much before sending new data if we do not have much data.
// #define MAX_BUFF (1500 - 68) // The ethernet MTU is 1500 bytes minus the IP/TCP headers.
#define MAX_SEND_QUEUE 10


struct sparrow_t {
  int fd;
  int event_cur;
  int events_len;
  struct epoll_event events [MAX_EVENTS];
  void * tr_socks; // A tree container of sockets.
};

typedef struct sparrow_t sparrow_t;

sparrow_t * sparrow_init(sparrow_t * sp) {
  int fd = epoll_create1 (0);
  if (fd == -1) {
    perror("epoll_create1 failed to create epoll.");
    abort();
  }
  sp-%gtfd = fd;
  sp-%gtevents_len = 0;
  return sp;
}

```


```c

//TODO These function definitions need to be removed.
typedef void * val_fn_t (void ** data_in,int * in_len, void * val_data); //The validator function returns the new buffer and int that is to be used
                                                                         // as an imput buffer. The returned data is NULL if we need more validation
                                                                         // or the data themselves that are then sent to be deserialized.
typedef void * deser_fn_t (void *validated_data);
typedef void * ser_fn_t (void * data);

struct data_out_t {
  void * data;
  int len;
};

typedef struct data_out_t data_out_t;

struct sparrow_socket_t {
  int listening; //BOOL
  int fd;
  int timeout;
  int out_cur;
  data_out_t data_out[MAX_SEND_QUEUE];
  int out_queue_pos;
  int out_queue_frst_free_pos;
  int in_len;
  int in_cur;
  int in_min;
  void * data_in;
};

typedef struct sparrow_socket_t sparrow_socket_t;


int cmp_ints(const void * sock1, const void * sock2) {
  const sparrow_socket_t * s1 = (const sparrow_socket_t *) sock1;
  const sparrow_socket_t * s2 = (const sparrow_socket_t *) sock2;
  return (s1-%gtfd %gt s2-%gtfd) - (s1-%gtfd %lt s2-%gtfd);
}


//internal use only
void sparrow_add_socket(sparrow_t * sp, sparrow_socket_t *sock) {
  int result;
  struct epoll_event event;
  event.data.fd = sock-%gtfd;
  event.events = EPOLLIN;
  result = epoll_ctl (sp-%gtfd, EPOLL_CTL_ADD, sock-%gtfd, &event);
  if (result == -1) {
    perror(" epoll_ctl failed to add a socket to epoll");
    abort();
  }
  assert(tfind(sock, &(sp-%gttr_socks), cmp_ints) == NULL);
  void *rtsearch = tsearch(sock, &(sp-%gttr_socks), cmp_ints);
  assert(rtsearch == sock);
}

//internal use only.
sparrow_socket_t * sparrow_socket_new(int fd) {
  sparrow_socket_t * sock = malloc(sizeof(sparrow_socket_t));
  memset(sock,0,sizeof(sparrow_socket_t));
  sock-%gtfd = fd;
  return sock;
}

//internal use only
sparrow_socket_t * sparrow_socket_set_non_blocking(sparrow_socket_t * sock) {
  int flags, result;

  flags = fcntl (sock-%gtfd, F_GETFL, 0);
  if (flags == -1) {
    perror ("fcntl failed to perform an action.");
    abort();
  }

  flags |= O_NONBLOCK;
  result = fcntl (sock-%gtfd, F_SETFL, flags);
  if (result == -1) {
    perror ("fcntl failed to perform an action.");
    abort();
  }
  return sock;
}

//internal function
sparrow_socket_t * sparrow_socket_listen(sparrow_socket_t * sock) {
  int result = listen(sock-%gtfd,SOMAXCONN);
  if ( result == -1 ) {
    perror("The socket failed to listen.");
    abort();
  }
  sock-%gtlistening = 1;
  return sock;
}

sparrow_socket_t * sparrow_socket_bind(sparrow_t * sp, char * port) {
  struct addrinfo hints = {0};
  struct addrinfo *ret_addr;
  int result, sfd;
  int flag = 1;

  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = AI_PASSIVE;

  result = getaddrinfo (NULL, port, &hints, &ret_addr);
  assert(result == 0);

  sfd = socket (ret_addr-%gtai_family, ret_addr-%gtai_socktype, ret_addr-%gtai_protocol);
  assert(sfd != -1);
  
  result = setsockopt(sfd,IPPROTO_TCP,TCP_NODELAY, (char *) &flag,sizeof(int));
  assert(result == 0);

  result = bind (sfd, ret_addr-%gtai_addr, ret_addr-%gtai_addrlen);
  if (result != 0) {
    close (sfd);
    abort();
  }
  sparrow_socket_t * sock = sparrow_socket_new(sfd);
  freeaddrinfo (ret_addr);
  sparrow_socket_set_non_blocking(sock); 
  sparrow_add_socket(sp,sock);
  sparrow_socket_listen(sock);
  return sock;
}



sparrow_socket_t * sparrow_socket_connect(sparrow_t * sp, char * address, char * port) {
  struct addrinfo hints = {0};
  struct addrinfo *ret_addr;
  int result, sfd;

  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = AI_PASSIVE;

  result = getaddrinfo (address, port, &hints, &ret_addr);
  assert(result == 0);

  sfd = socket (ret_addr-%gtai_family, ret_addr-%gtai_socktype, ret_addr-%gtai_protocol);
  assert(sfd != -1);
  result = connect (sfd, ret_addr-%gtai_addr, ret_addr-%gtai_addrlen);
  if (result != 0) {
    close (sfd);
    abort();
  }
  sparrow_socket_t * sock = sparrow_socket_new(sfd);
  freeaddrinfo (ret_addr);
  sparrow_socket_set_non_blocking(sock); 
  sparrow_add_socket(sp,sock);
  return sock;
}

void sparrow_socket_close(sparrow_t * sp, sparrow_socket_t * sock) {
  close(sock-%gtfd);
  assert(sock-%gtdata_in == NULL);
  void * isItNull  = tdelete(sock, &(sp-%gttr_socks), cmp_ints);
  assert(isItNull != NULL);
  free(sock);
}


//internal use only.
void sparrow_socket_accept(sparrow_t * sp, sparrow_socket_t * lsock) {
  int nsfd = accept4(lsock-%gtfd,NULL,NULL,SOCK_NONBLOCK);
  assert(nsfd != -1);
  sparrow_socket_t * sock = sparrow_socket_new(nsfd);
  sparrow_add_socket(sp,sock);
}

```

Sparrow_wait returns data when all the data have been received.

```c

//Internal use only.
//Requires an array of MAX_EVENT units.
void * sparrow_wait(sparrow_t * sp, int timeout, int *sfd,int *in_min) {
  if(sp-%gtevents_len == 0) {
    sp-%gtevents_len = epoll_wait(sp-%gtfd, sp-%gtevents, MAX_EVENTS, timeout);
    //TODO Handle the errors.
    sp-%gtevent_cur = 0;
  }
  int i;
  sparrow_socket_t find_sock;
  for( i = sp-%gtevent_cur; i %lt sp-%gtevents_len; i++) {
    find_sock.fd = sp-%gtevents[i].data.fd; 
    sparrow_socket_t * sock = tfind(&find_sock, &(sp-%gttr_socks), cmp_ints);
    int event = sp-%gtevents[i].events;
    
    if(event & EPOLLIN) {

      if(sock-%gtlistening) {
// We accept a new client.
        sparrow_socket_accept(sp, sock);
      } else {

        assert(sock-%gtin_len %gt sock-%gtin_cur);
        assert(sock-%gtin_min %lt sock-%gtin_cur);
        int result = recv(sock-%gtfd, sock-%gtdata_in + sock-%gtin_cur, sock-%gtin_len - sock-%gtin_cur, 0);
        assert(result %gt 0); //TODO we need to throw an error when the connection was shutdown. (result =0)
        if(result + sock-%gtin_cur %gt= sock-%gtin_min) {
          *in_min = result + sock-%gtin_cur;

          sock-%gtin_cur = 0;
          sock-%gtin_len = 0;
          sock-%gtin_min = 0;

          if(i == sp-%gtevents_len) {
            sp-%gtevents_len = 0;
          }
          *sfd = sock-%gtfd;
          return sock-%gtdata_in;
        } else {
          sock-%gtin_cur += result;
        }
      }
    }

    if(event & EPOLLOUT) {
      assert(sock-%gtout_queue_pos != sock-%gtout_queue_frst_free_pos);
      data_out_t data_out = sock-%gtdata_out[sock-%gtout_queue_pos];
      assert(data_out.len %gt sock-%gtout_cur);
      int result = send(sock-%gtfd, data_out.data + sock-%gtout_cur, data_out.len - sock-%gtout_cur, 0);
      assert(result %gt 0);

      if(result + sock-%gtout_cur == data_out.len) {
        free(data_out.data);
        sock-%gtout_queue_pos = (sock-%gtout_queue_pos + 1) % MAX_SEND_QUEUE;
        sock-%gtout_cur = 0;

        if(sock-%gtout_queue_pos == sock-%gtout_queue_frst_free_pos) {
          struct epoll_event event;
          event.data.fd = sock-%gtfd;
          event.events = EPOLLIN;
          result = epoll_ctl (sp-%gtfd, EPOLL_CTL_MOD, sock-%gtfd, &event);
          if (result == -1) {
            perror(" epoll_ctl failed to modify a socket to epoll");
            abort();
          }
        }

      } else {
        sock-%gtout_cur += result;
      }
    }
  }
  sp-%gtevents_len = 0;
  return sparrow_wait(sp, timeout, sfd, in_min);
}

// void  sparrow_send()



```



       </div>
    </div>
</body>
</html>
