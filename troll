
df
#define _GNU_SOURCE

#include %ltsys/epoll.h%gt
#include %lterrno.h%gt
#include %ltstdio.h%gt
#include %ltsys/socket.h%gt
#include %ltsys/types.h%gt
#include %ltnetdb.h%gt
#include %ltunistd.h%gt
#include %ltassert.h%gt
#include %ltstring.h%gt
#include %ltfcntl.h%gt
#include %lttime.h%gt
#include %ltstdlib.h%gt
#include %ltnetinet/in.h%gt
#include %ltnetinet/tcp.h%gt
#include "tree.h"
#include "sparrow.h"

#define MAX_EVENTS 32
// #define MAX_DELAY 40 //in milliseconds. We wait that much before sending new data if we do not have much data.
// #define MAX_BUFF (1500 - 68) // The ethernet MTU is 1500 bytes minus the IP/TCP headers.
// One millisecond clock precision.
#define CLOCK_PRECISION 1000000
#define MAX_SEND_QUEUE 10


int64_t os_now(void) {
  struct timespec ts;
  int rc = clock_gettime(CLOCK_MONOTONIC, &ts);
  assert (rc == 0);
  return ((int64_t) ts.tv_sec) * 1000 + (((int64_t) ts.tv_nsec) / 1000000);
}

int64_t now(void) {
  uint32_t low;
  uint32_t high;
  __asm__ volatile("rdtsc" : "=a" (low), "=d" (high));
  int64_t tsc = (int64_t)((uint64_t)high %lt%lt 32 | low);

  static int64_t last_tsc = -1;
  static int64_t last_now = -1;
  if(__builtin_expect(!!(last_tsc %lt 0), 0)) {
    last_tsc = tsc;
    last_now = os_now();
  }   

  if(__builtin_expect(!!(tsc - last_tsc %lt= (CLOCK_PRECISION / 2) && tsc %gt= last_tsc), 1))
    return last_now;

  last_tsc = tsc;
  last_now = os_now();
  return last_now;
}


//The current position is set by the multiplexer/serializer.

struct data_out_t {
  size_t cur;
  void * data;
  size_t len;
};

struct data_in_t {   //Send the data to the multiplexer/serializer when no more data are coming(?) or the buffer is full. The data present might be incomplete, thus the multiplexer will send the same buffer with the curr at the correct position.
  size_t cur;
  void * data;
  size_t len;
};

typedef struct data_out_t data_out_t;
typedef struct data_in_t data_in_t;

struct sparrow_socket_t {
  int listening; //BOOL
  int fd;
  int64_t expiry;
  data_out_t data_out;
  data_in_t data_in;
  RB_ENTRY (sparrow_socket_t) to_field;
  RB_ENTRY (sparrow_socket_t) fd_field;
};

typedef struct sparrow_socket_t sparrow_socket_t;

int cmp_fds(const void * sock1, const void * sock2) {
  const sparrow_socket_t * s1 = (const sparrow_socket_t *) sock1;
  const sparrow_socket_t * s2 = (const sparrow_socket_t *) sock2;
  return (s1-%gtfd %gt s2-%gtfd) - (s1-%gtfd %lt s2-%gtfd);
}

int cmp_tos(const void * sock1, const void * sock2) {
  const sparrow_socket_t * s1 = (const sparrow_socket_t *) sock1;
  const sparrow_socket_t * s2 = (const sparrow_socket_t *) sock2;
  return (s1-%gtexpiry %gt s2-%gtexpiry) - (s1-%gtexpiry %lt s2-%gtexpiry);
}



RB_HEAD (to_rb_t, sparrow_socket_t);
RB_PROTOTYPE (to_rb_t, sparrow_socket_t, to_field,cmp_tos);

RB_HEAD (fd_rb_t, sparrow_socket_t);
RB_PROTOTYPE (fd_rb_t, sparrow_socket_t, fd_field, cmp_fds);

RB_GENERATE (to_rb_t, sparrow_socket_t, to_field,cmp_tos);
RB_GENERATE (fd_rb_t, sparrow_socket_t, fd_field, cmp_fds);



struct sparrow_t {
  int fd;
  int event_cur;
  int events_len;
  struct epoll_event events [MAX_EVENTS];
  struct fd_rb_t * fd_rb_socks; // A tree container of sockets ordered by the fd.
  struct to_rb_t * to_rb_socks; // A tree container of sockets ordered by the expiry.
  size_t already_expired;
};


sparrow_t * sparrow_new(void) {
  sparrow_t * sp = calloc(1,sizeof(sparrow_t));
  int fd = epoll_create1 (0);
  if (fd == -1) {
    perror("epoll_create1 failed to create epoll.");
    abort();
  }
  sp-%gtfd = fd;
  sp-%gtevents_len = 0;
  RB_INIT(sp-%gtfd_rb_socks);
  RB_INIT(sp-%gtto_rb_socks);
  return sp;
}

