./!dots(1)
#include "msparrow.h"
#include "bsparrow.h"
#include%ltstring.h%gt 
#include%ltassert.h%gt 

void msparrow_recv(bsparrow_t * bsp, bsparrow_socket_t * bsock) {
  bsparrow_recv(bsp, bsock, 8);
}

./!dots(-1)
function do_we_have_all_data() {
./!dots(+1)

if(*size + 8 %gt bspev-%gttotal_length) {
  return NULL;
} else {
  data = scalloc(1, *size);
}

./!dots(-1)
}
./!dots(+1)

//Internal use only.
void * get_data(bsparrow_event_t * bspev,  uint64_t * size) {
  char * data = NULL;

  size_t position = 0;
  size_t step_position = 0;
  buffer_list_t * iter = bspev-%gtlist;

  if(bspev-%gtfirst_buffer_length %gt 0) {
     if(8 %gt bspev-%gtfirst_buffer_length) {
      memcpy(size, bspev-%gtfirst_buffer, bspev-%gtfirst_buffer_length);
      position = bspev-%gtfirst_buffer_length;
    } else {
      memcpy(size, bspev-%gtfirst_buffer, 8);
./!dots(-1)
.      @{do_we_have_all_data()}
./!dots(+1)
      goto step_zero;
    }
  }

  if(iter != NULL) {
    char * buffer;
    size_t length;
    iter = buffer_list_next(iter, &buffer, &length);    //length here must be big enough to have the 8 bits.
    assert(length %gt= (8 - position));
    memcpy(size + position, buffer, 8 - position);
./!dots(-1)
.    @{do_we_have_all_data()}
./!dots(+1)
    memcpy(data, buffer - (8 - position), length - (8 - position));   
    position = length - (8 - position);
    goto step_one;
  }
 
  if(bspev-%gtlast_buffer_length %gt 8 - position) {
    memcpy(size + position, bspev-%gtlast_buffer, 8 - position);
./!dots(-1)
.    @{do_we_have_all_data()}
./!dots(+1)
    step_position = 8 - position;
    position = 0;
    goto step_two;
  }

  assert(1 == 0);

step_zero: ;

  if(bspev-%gtfirst_buffer_length - 8 %gt 0) {
    if(*size %gt bspev-%gtfirst_buffer_length - 8) {
      memcpy(data, bspev-%gtfirst_buffer + 8, bspev-%gtfirst_buffer_length - 8);
      position = bspev-%gtfirst_buffer_length;
    } else {
      memcpy(data, bspev-%gtfirst_buffer + 8, *size);
      return data;
    }
  }

step_one: ;

  while(iter != NULL) {
    char * buffer;
    size_t length;
    iter = buffer_list_next(iter, &buffer, &length);
    memcpy(data + position, buffer, length);
    position += length;
  }

step_two: ;
 
  if(bspev-%gtlast_buffer_length) {
    memcpy(data + position, bspev-%gtlast_buffer + step_position, *size - position);
  }

  return data;
}

int msparrow_get_msg(bsparrow_t * bsp, bsparrow_event_t * bspev, msparrow_msg_t * msg) {
  assert(bspev-%gtevent == 4);
  
  if(bspev-%gttotal_length %lt 8) {
    bsparrow_recv(bsp, bspev-%gtbsock, 8);
    return 0;
  } else {
    msg-%gtdata = get_data(bspev, &(msg-%gtlen));
    if(msg-%gtdata == NULL) {
      bsparrow_recv(bsp, bspev-%gtbsock, msg-%gtlen + 8);
      return 0;
    } else {
      bsparrow_got_some(bsp, bspev-%gtbsock, msg-%gtlen + 8);
      return 1; 
    }
  }
}

./!dots(-1)
